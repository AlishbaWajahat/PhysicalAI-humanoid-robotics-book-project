---
id: chapter-3-ros-2-crash-course
title: "Chapter 3: ROS 2 Crash Course"
sidebar_label: "Chapter 3: ROS 2 Crash Course"
description: "Core ROS 2 architecture concepts including nodes, topics, services, and actions with hands-on examples."
---

# Chapter 3: ROS 2 Crash Course

Welcome to your first deep dive into ROS 2! In this chapter, you'll master the fundamental building blocks of ROS 2 architecture. You'll create your first nodes, establish communication between them, and understand how the "nervous system" of robots actually works. By the end of this chapter, you'll have built and run your first publisher/subscriber pair — a foundational ROS 2 pattern.

## Learning Objectives

After completing this chapter, you will be able to:
- Explain the core components of ROS 2 architecture (nodes, topics, services, actions)
- Create basic ROS 2 publisher and subscriber nodes in Python
- Understand Quality of Service (QoS) settings and their impact
- Run and test simple ROS 2 communication patterns
- Troubleshoot common ROS 2 communication issues

## Why This Matters in 2025

Understanding ROS 2 fundamentals is crucial for connecting your AI agents to physical robotic systems. Every robotic application — from autonomous vehicles to warehouse robots to space exploration vehicles — relies on the communication patterns you'll learn here. The publisher-subscriber model you'll master is the backbone of how sensors share data with AI decision-making systems and how those systems send commands back to robot actuators.

## Core Concepts: The Building Blocks of ROS 2

### Nodes — The Computational Units

Think of nodes as the individual processes that perform specific functions in your robotic system. Just as your brain has specialized regions for vision, movement, and decision-making, a robot's intelligence is distributed across multiple nodes, each responsible for a specific task.

**In Plain English:** A node is like a specialized worker in a factory — it has a specific job and communicates with other workers to get complex tasks done.

**Technically:** A node is a process that performs computation and communicates with other nodes using ROS 2's communication infrastructure. Each node can publish to topics, subscribe to topics, provide services, or call services.

### Topics — The Communication Channels

Topics are the primary way nodes share information in ROS 2. They use a publish-subscribe model where one node publishes data and multiple nodes can subscribe to receive that same data.

**In Plain English:** Topics are like radio stations — one node broadcasts information (like sensor data), and any number of other nodes can "tune in" to receive that information.

**Technically:** Topics are named buses over which nodes exchange messages using a publish-subscribe pattern. Publishers send messages to a topic, and subscribers receive messages from that topic.

### Services and Actions — Request-Response Communication

While topics handle continuous data streams, services provide synchronous request-response communication. Actions are similar but designed for long-running tasks that provide feedback during execution.

## Hands-On: Creating Your First Publisher and Subscriber (Under 50 Lines Each)

Let's create your first ROS 2 publisher and subscriber nodes. This is the "Hello World" of ROS 2, but instead of printing text to the console, we're sending messages between nodes!

### Creating the Publisher Node

```python
# File: talker.py
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class TalkerNode(Node):
    def __init__(self):
        super().__init__('talker')
        self.publisher = self.create_publisher(String, 'chatter', 10)
        timer_period = 0.5  # seconds
        self.timer = self.create_timer(timer_period, self.timer_callback)
        self.i = 0

    def timer_callback(self):
        msg = String()
        msg.data = f'Hello ROS 2 World: {self.i}'
        self.publisher.publish(msg)
        self.get_logger().info(f'Publishing: "{msg.data}"')
        self.i += 1

def main(args=None):
    rclpy.init(args=args)
    talker = TalkerNode()

    try:
        rclpy.spin(talker)
    except KeyboardInterrupt:
        pass
    finally:
        talker.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

This publisher node creates a timer that publishes a message every 0.5 seconds to the 'chatter' topic. The message contains a simple string with an incrementing counter.

### Creating the Subscriber Node

```python
# File: listener.py
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class ListenerNode(Node):
    def __init__(self):
        super().__init__('listener')
        self.subscription = self.create_subscription(
            String,
            'chatter',
            self.listener_callback,
            10)
        self.subscription  # prevent unused variable warning

    def listener_callback(self, msg):
        self.get_logger().info(f'I heard: "{msg.data}"')

def main(args=None):
    rclpy.init(args=args)
    listener = ListenerNode()

    try:
        rclpy.spin(listener)
    except KeyboardInterrupt:
        pass
    finally:
        listener.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

This subscriber node listens to the 'chatter' topic and prints whatever messages it receives to the console.

### Running Your First ROS 2 Nodes

To run these nodes, you'll need to:

1. **Create a ROS 2 package** (we'll cover this in Chapter 5):
```bash
ros2 pkg create --build-type ament_python my_first_ros_nodes
```

2. **Place your files in the package**:
```text
my_first_ros_nodes/
├── my_first_ros_nodes/
│   ├── __init__.py
│   ├── talker.py
│   └── listener.py
├── setup.py
└── setup.cfg
```

3. **Run the publisher in one terminal**:
```bash
ros2 run my_first_ros_nodes talker
```

4. **Run the subscriber in another terminal**:
```bash
ros2 run my_first_ros_nodes listener
```

You should see the publisher sending messages and the subscriber receiving them!

## Quality of Service (QoS) Settings

Quality of Service settings determine how messages are delivered between nodes. For beginners, the default settings (like the `10` in our publisher/subscriber creation) are usually fine, but understanding QoS is important for more advanced applications.

- **Reliability**: Whether messages must be delivered (reliable) or can be dropped (best effort)
- **Durability**: Whether messages persist for late-joining subscribers (transient_local) or are only sent to current subscribers (volatile)
- **History**: How many messages to keep in the queue (keep_last N or keep_all)

## Common Beginner Mistakes & Instant Fixes

**Mistake**: Nodes can't communicate with each other
- **What you'll see**: Publisher runs but subscriber shows no messages
- **One-line fix**: Check that topic names match exactly (including case) between publisher and subscriber

**Mistake**: "Node name already in use" error
- **What you'll see**: Error message about duplicate node names
- **One-line fix**: Use unique node names or add random suffixes when creating nodes

**Mistake**: Import errors when running nodes
- **What you'll see**: "ModuleNotFoundError" for rclpy or std_msgs
- **One-line fix**: Make sure your ROS 2 environment is sourced: `source /opt/ros/humble/setup.bash`

## Verify Success

Run this command to verify your ROS 2 installation and communication is working:

```bash
# Check that your ROS 2 environment is working
ros2 topic list
```

If you see topics listed (even if empty), your ROS 2 environment is properly set up and ready for the next chapter.

## What's Next?

In Chapter 4, you'll learn how to describe and visualize robots using URDF (Unified Robot Description Format) and see your creations in RViz2, the 3D visualization tool. You'll move from abstract communication patterns to concrete robot representations — seeing your first virtual robot come to life!

## Key Terms Defined

- **Node**: A process that performs computation and communicates with other nodes
- **Topic**: A named bus for message exchange using publish-subscribe pattern
- **Publisher**: A node that sends messages to a topic
- **Subscriber**: A node that receives messages from a topic
- **Quality of Service (QoS)**: Settings that control message delivery behavior
- **rclpy**: The Python client library for ROS 2
- **std_msgs**: Standard message types for common data types like String, Int32, etc.
- **ros2 run**: Command to run a specific executable in a ROS 2 package

## Understanding ROS 2 Middleware and DDS

ROS 2 uses DDS (Data Distribution Service) as its underlying middleware, which provides the infrastructure for reliable communication between nodes. DDS handles the complex networking details, allowing nodes to communicate seamlessly whether they're running on the same machine or distributed across multiple computers.

DDS provides several key capabilities:
- **Discovery**: Nodes automatically find each other on the network
- **Reliable delivery**: Messages are guaranteed to arrive (when configured for reliability)
- **Real-time support**: Deterministic timing for time-critical applications
- **Security**: Authentication, encryption, and access control

Different DDS implementations are available with ROS 2, including Fast DDS (default), Cyclone DDS, and RTI Connext DDS. Each has its own strengths and is suitable for different applications.

## Working with Message Types

ROS 2 comes with a rich set of predefined message types in packages like std_msgs, geometry_msgs, sensor_msgs, and more. These standard messages allow different packages to communicate using common formats.

For example:
- **std_msgs**: Basic data types like String, Int32, Float64, Bool
- **geometry_msgs**: 3D geometry types like Point, Pose, Twist, Quaternion
- **sensor_msgs**: Sensor-specific messages like JointState, LaserScan, Image
- **nav_msgs**: Navigation-related messages like Path, OccupancyGrid

You can also create custom message types by defining .msg files in your packages, which ROS 2 automatically converts to language-specific code for Python, C++, and other supported languages.

## Advanced Node Features

ROS 2 nodes can do much more than just publish and subscribe. They can also provide services, call services, and work with actions for more complex interactions.

### Parameters

Nodes can accept parameters that can be configured at runtime:
```python
# Declare a parameter in your node
self.declare_parameter('publish_frequency', 1.0)

# Get the parameter value
frequency = self.get_parameter('publish_frequency').value
```

### Timers

Timers allow nodes to execute callbacks at regular intervals:
```python
# Create a timer that calls a function every second
timer_period = 1.0  # seconds
self.timer = self.create_timer(timer_period, self.timer_callback)
```

### Callback Groups

For more complex nodes, you can organize callbacks into groups to control their execution:
```python
# Create a callback group
callback_group = rclpy.callback_groups.MutuallyExclusiveCallbackGroup()

# Use it when creating subscriptions or services
self.subscription = self.create_subscription(
    String,
    'topic',
    self.callback,
    10,
    callback_group=callback_group
)
```

## ROS 2 Command Line Tools

ROS 2 provides many command-line tools to help you understand and debug your system:

- `ros2 node list`: Show all active nodes
- `ros2 topic list`: Show all active topics
- `ros2 service list`: Show all available services
- `ros2 param list <node_name>`: Show parameters for a specific node
- `ros2 topic echo <topic_name>`: Print messages from a topic
- `ros2 topic pub <topic_name> <msg_type> <values>`: Publish a message

These tools are invaluable for understanding what's happening in your ROS 2 system and for debugging communication issues.

## Best Practices for ROS 2 Development

1. **Use meaningful names**: Choose descriptive names for nodes, topics, and parameters
2. **Handle shutdown gracefully**: Always clean up resources when nodes are destroyed
3. **Use appropriate QoS settings**: Match your QoS settings to your application requirements
4. **Log appropriately**: Use different log levels (info, warn, error, debug) appropriately
5. **Test communication**: Verify that nodes can communicate as expected in your system

## Performance Considerations

When designing ROS 2 systems, consider the following performance factors:
- **Message frequency**: High-frequency topics can consume significant bandwidth
- **Message size**: Large messages can impact network performance
- **Node design**: Keep nodes focused on specific tasks for better maintainability
- **Resource usage**: Monitor CPU and memory usage of your nodes

## Troubleshooting Common Issues

**Issue**: Nodes can't find each other
- **Solution**: Check that nodes are on the same ROS domain ID
- **Command**: `echo $ROS_DOMAIN_ID` to verify domain ID

**Issue**: High CPU usage
- **Solution**: Check timer frequencies and message rates
- **Check**: Are you publishing messages too frequently?

**Issue**: Memory leaks
- **Solution**: Ensure proper cleanup in node destruction
- **Verify**: All timers and subscriptions are properly destroyed

## Integration with AI Systems

ROS 2 is particularly powerful when integrated with AI systems. Your AI agents can:
- Subscribe to sensor data to understand the environment
- Publish commands to control robot actions
- Use services to request specific information
- Monitor robot state through various topics

This creates the complete loop: AI processes sensor data → AI makes decisions → AI sends commands → Robot acts → Sensors provide feedback.

## Real-World ROS 2 Applications

ROS 2 is used in a wide variety of real-world applications across different industries:

**Autonomous Vehicles**: Self-driving cars use ROS 2 to process data from cameras, LIDAR, radar, and GPS sensors to make navigation decisions and control vehicle movement.

**Warehouse Automation**: Companies like Amazon use ROS 2-based systems to control thousands of robots that move products around warehouses efficiently.

**Space Exploration**: NASA's Ingenuity helicopter on Mars used ROS 2 for some of its ground-based testing and simulation.

**Healthcare Robotics**: Surgical robots, rehabilitation robots, and assistive robots for elderly care all use ROS 2 for reliable communication between sensors and actuators.

**Agriculture**: Autonomous tractors, harvesting robots, and monitoring systems use ROS 2 to process environmental data and control mechanical systems.

## Understanding Quality of Service (QoS) in Depth

Quality of Service settings are crucial for creating robust ROS 2 applications. Let's explore each setting in more detail:

### Reliability Policy
- **Reliable**: Every message is guaranteed to be delivered (if possible), with retries for failed transmissions
- **Best Effort**: Messages are sent without guarantees - faster but may be lost

### Durability Policy
- **Transient Local**: Late-joining subscribers receive the last message published on the topic
- **Volatile**: Only messages published after a subscriber joins are received

### History Policy
- **Keep Last**: Maintain only the N most recent messages
- **Keep All**: Maintain all messages (use with caution - can consume lots of memory)

### Depth
The number of messages to store in the history queue when using "Keep Last" policy.

Example of setting specific QoS for a publisher:
```python
from rclpy.qos import QoSProfile, QoSReliabilityPolicy, QoSHistoryPolicy

# Create a QoS profile for real-time sensor data
sensor_qos = QoSProfile(
    depth=10,
    reliability=QoSReliabilityPolicy.BEST_EFFORT,
    history=QoSHistoryPolicy.KEEP_LAST
)

# Use it when creating a publisher
self.publisher = self.create_publisher(String, 'sensor_data', sensor_qos)
```

## Services in ROS 2

While topics are great for continuous data streams, services provide synchronous request-response communication. Here's how to create a service server and client:

### Service Server
```python
import rclpy
from rclpy.node import Node
from example_interfaces.srv import AddTwoInts

class MinimalService(Node):
    def __init__(self):
        super().__init__('minimal_service')
        self.srv = self.create_service(AddTwoInts, 'add_two_ints', self.add_two_ints_callback)

    def add_two_ints_callback(self, request, response):
        response.sum = request.a + request.b
        self.get_logger().info(f'Returning {response.sum}')
        return response

def main(args=None):
    rclpy.init(args=args)
    minimal_service = MinimalService()
    rclpy.spin(minimal_service)
    minimal_service.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Service Client
```python
import rclpy
from rclpy.node import Node
from example_interfaces.srv import AddTwoInts

class MinimalClient(Node):
    def __init__(self):
        super().__init__('minimal_client')
        self.cli = self.create_client(AddTwoInts, 'add_two_ints')
        while not self.cli.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('Service not available, waiting again...')
        self.req = AddTwoInts.Request()

    def send_request(self, a, b):
        self.req.a = a
        self.req.b = b
        future = self.cli.call_async(self.req)
        return future

def main(args=None):
    rclpy.init(args=args)
    minimal_client = MinimalClient()
    future = minimal_client.send_request(1, 2)

    rclpy.spin_until_future_complete(minimal_client, future)
    response = future.result()
    minimal_client.get_logger().info(f'Result: {response.sum}')

    minimal_client.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Actions in ROS 2

Actions are used for long-running tasks that provide feedback during execution. They're perfect for robot navigation, arm movements, or any task that takes time and needs monitoring.

### Action Server
Actions use the action_msgs package and provide three key components:
1. Goal: What you want to accomplish
2. Feedback: Updates during execution
3. Result: Final outcome

This is more appropriate than services for tasks that take time to complete, like moving a robot to a specific location.

## Launch Files Overview

While we'll cover launch files in detail in Chapter 5, it's worth noting that ROS 2 nodes are typically run using launch files rather than individual commands. This allows you to start multiple nodes with specific configurations simultaneously.

A simple launch file looks like:
```python
from launch import LaunchDescription
from launch_ros.actions import Node

def generate_launch_description():
    return LaunchDescription([
        Node(
            package='my_package',
            executable='talker',
            name='talker_node'
        ),
        Node(
            package='my_package',
            executable='listener',
            name='listener_node'
        )
    ])
```

## Security in ROS 2

ROS 2 includes security features through SROS2 (Secure ROS 2), which provides:
- Authentication: Verifying the identity of nodes
- Authorization: Controlling what nodes can do
- Encryption: Protecting message contents

These features are essential for deploying ROS 2 systems in production environments where security is critical.

## Testing ROS 2 Nodes

ROS 2 provides testing frameworks that allow you to verify your nodes work correctly:

- **Unit tests**: Test individual functions and methods
- **Integration tests**: Test communication between nodes
- **System tests**: Test complete robotic systems

Testing is crucial for creating reliable robotic applications that can operate safely in real-world environments.

## ROS 2 Ecosystem and Package Management

ROS 2 uses ament as its build system and has a rich ecosystem of packages available through the ROS package index. Common categories include:

- **Perception**: Computer vision, LIDAR processing, sensor fusion
- **Control**: PID controllers, trajectory generation, motor control
- **Navigation**: Path planning, localization, mapping
- **Simulation**: Gazebo integration, physics engines
- **Hardware interfaces**: Drivers for specific sensors and actuators

## Migration from ROS 1 to ROS 2

If you're familiar with ROS 1, there are several key differences in ROS 2:
- Different build system (ament vs catkin)
- DDS-based middleware instead of custom transport
- Improved security and real-time capabilities
- Better multi-robot support
- Python 3 support by default

However, the core concepts of nodes, topics, services, and parameters remain similar, making the transition manageable.

## Working with Time in ROS 2

Time is crucial in robotics applications, and ROS 2 provides robust time handling capabilities:

### ROS Time vs System Time
ROS 2 can use different time sources:
- **System time**: Real-world clock time
- **Simulated time**: Time from a simulator like Gazebo
- **Custom time sources**: For specialized applications

```python
# Get the current ROS time
current_time = self.get_clock().now()

# Convert to seconds
time_in_seconds = current_time.nanoseconds / 1e9
```

### Timers and Rate Control
For consistent timing in your nodes:
```python
# Timer-based execution
self.timer = self.create_timer(0.1, self.timer_callback)  # Every 0.1 seconds

# Rate-based execution (for loops)
from rclpy.qos import QoSProfile
from rclpy.qos import QoSDurabilityPolicy

# Create a rate object for 10 Hz execution
rate = self.create_rate(10)  # 10 Hz
while rclpy.ok():
    # Your code here
    rate.sleep()  # Maintains 10 Hz rate
```

## Understanding Node Lifecycle

ROS 2 nodes have a well-defined lifecycle that includes several states:
- **Unconfigured**: Node created but not configured
- **Inactive**: Configured but not active
- **Active**: Running and operational
- **Finalized**: Shutting down

This lifecycle management is particularly useful for complex robotic systems where you need fine-grained control over when nodes start and stop.

## Memory Management in ROS 2

Efficient memory usage is important for robotic applications:
- **Message allocation**: ROS 2 reuses message objects when possible
- **Buffer management**: QoS settings affect memory usage
- **Resource cleanup**: Always destroy nodes and clean up resources

```python
def destroy_node(self):
    # Clean up timers
    self.timer.cancel()
    # Clean up subscriptions/publishers
    # Additional cleanup code
    super().destroy_node()
```

## Debugging ROS 2 Applications

Effective debugging techniques for ROS 2:

### Using ROS 2 Command Line Tools
```bash
# Monitor a specific topic
ros2 topic echo /my_topic

# Monitor node status
ros2 lifecycle list my_node

# Get detailed information about a node
ros2 node info my_node
```

### Logging Best Practices
```python
# Use appropriate log levels
self.get_logger().debug('Detailed debugging info')
self.get_logger().info('Normal operational info')
self.get_logger().warn('Warning about potential issues')
self.get_logger().error('Non-critical error occurred')
self.get_logger().fatal('Critical error - shutting down')
```

## Performance Optimization

To optimize your ROS 2 applications:

### Message Optimization
- Use appropriate data types (avoid strings when integers work)
- Consider message compression for large data
- Use efficient serialization formats

### Network Optimization
- Use appropriate QoS settings for your application
- Consider local vs. remote communication needs
- Monitor network bandwidth usage

### Computational Optimization
- Profile your nodes to identify bottlenecks
- Use multithreading when appropriate
- Consider real-time scheduling for critical tasks

## Common Design Patterns in ROS 2

### Publisher-Subscriber Pattern (Extended)
The basic pattern we covered, but with additional considerations:
- Multiple publishers for the same topic
- Multiple subscribers to the same topic
- Fan-out and fan-in architectures

### Client-Server Pattern
For request-response communication:
- Service calls for synchronous operations
- Action calls for long-running operations
- Parameter services for configuration

### Blackboard Pattern
Using shared parameters or topics for coordination:
- Shared state between nodes
- Configuration coordination
- Status sharing

## ROS 2 with Different Programming Languages

While we've focused on Python, ROS 2 supports multiple languages:
- **C++**: For performance-critical applications
- **Python**: For rapid prototyping and AI integration
- **Rust**: For memory-safe applications
- **Java**: For Android robotics applications
- **Lisp**: For AI research applications

The interfaces are consistent across languages, allowing you to mix and match based on your needs.

## Integration with AI Frameworks

ROS 2 works well with popular AI frameworks:
- **TensorFlow/PyTorch**: For machine learning inference
- **OpenCV**: For computer vision applications
- **MoveIt**: For motion planning
- **Navigation2**: For path planning and navigation

Example of AI integration:
```python
import tensorflow as tf
from sensor_msgs.msg import Image

class AINode(Node):
    def __init__(self):
        super().__init__('ai_node')
        self.subscription = self.create_subscription(
            Image,
            'camera/image_raw',
            self.image_callback,
            10)
        # Load your AI model
        self.model = tf.keras.models.load_model('my_model.h5')

    def image_callback(self, msg):
        # Process image with AI model
        processed_data = self.process_with_ai(msg)
        # Publish results
        self.publish_results(processed_data)
```

## Testing and Simulation

Before deploying to real robots, always test in simulation:
- **Gazebo**: Physics-based simulation environment
- **Webots**: Another popular robotics simulator
- **Unit testing**: Test individual components
- **Integration testing**: Test node communication

## Building Robust ROS 2 Systems

### Error Handling
Always implement proper error handling:
```python
def safe_publish(self, msg):
    try:
        self.publisher.publish(msg)
    except Exception as e:
        self.get_logger().error(f'Failed to publish message: {e}')
```

### Graceful Degradation
Design systems that can continue operating when parts fail:
- Fallback behaviors
- Reduced functionality modes
- Error recovery procedures

### Monitoring and Diagnostics
Implement monitoring for production systems:
- Health checks
- Performance metrics
- Diagnostic messages

## Summary and Next Steps

In this comprehensive chapter, you've learned:
- The fundamental concepts of ROS 2 architecture
- How to create publisher and subscriber nodes
- Advanced features like services, actions, and parameters
- Best practices for ROS 2 development
- Integration with AI systems
- Performance optimization techniques

You now have a solid foundation in ROS 2 fundamentals that will serve you well as you continue through this textbook. The concepts you've learned here form the backbone of virtually all robotic systems built today.

## Resources for Continued Learning

To deepen your understanding of ROS 2, consider exploring these resources:

### Official Documentation
- ROS 2 Humble Hawksbill documentation: https://docs.ros.org/en/humble/
- Tutorials: https://docs.ros.org/en/humble/Tutorials.html
- API documentation for rclpy: https://docs.ros.org/en/humble/p/rclpy/

### Community Resources
- ROS Discourse: Community discussions and Q&A
- ROS Answers: Technical support forum
- GitHub repositories of popular ROS 2 packages
- YouTube channels with ROS 2 tutorials

### Practice Projects
To solidify your learning, try these practice projects:
1. Create a temperature monitoring system with multiple sensors
2. Build a simple robot controller that responds to keyboard input
3. Implement a data logger that saves sensor readings to files
4. Create a system that fuses data from multiple sensors

## Chapter Summary Checklist

By completing this chapter, you should now be able to:
- [ ] Explain the core components of ROS 2 (nodes, topics, services, actions)
- [ ] Create publisher and subscriber nodes in Python
- [ ] Understand and configure Quality of Service settings
- [ ] Use ROS 2 command-line tools for debugging
- [ ] Implement error handling in ROS 2 nodes
- [ ] Apply best practices for ROS 2 development
- [ ] Integrate AI frameworks with ROS 2 systems
- [ ] Design robust ROS 2 applications

Great job completing your first ROS 2 chapter! You now understand the fundamental communication patterns that power all robotic systems. The publisher-subscriber pattern you've learned is used by virtually every robot in the world to share sensor data, commands, and status information.